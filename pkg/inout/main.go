// Package inout contains functions that deal with io
// operations, reading and writing the contents of the
// files generated by [scf]
package inout

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/buger/jsonparser"
	"github.com/sergio-prgm/tf-module/pkg/util"
	"golang.org/x/exp/slices"
	"gopkg.in/yaml.v3"
)

type Modules struct {
	Name      string   `yaml:"name"`
	Resources []string `yaml:"resources"`
}

type F struct {
	Modules []Modules `yaml:"modules"`
	Confg   []string  `yaml:"config"`
}

type ParsedTf struct {
	Providers []string
	Resources []string
}

func ReadConfig(fileName string) F {
	filePath := fmt.Sprintf("%s/tfmodule.yaml", strings.TrimSuffix(fileName, "/"))
	conf, err := os.ReadFile(filePath)

	if err != nil {
		log.Fatalf("ERROR: %s doesn't exist", filePath)
	} else {
		fmt.Printf("Reading modules from %s\n", util.EmphasizeStr(filePath, util.Yellow, util.Normal))
	}

	return ParseConfig(conf)
}

// ParseConfig parses the contents of the provided yaml file
// into a usable struct
func ParseConfig(conf []byte) F {
	configModules := F{}
	err := yaml.Unmarshal(conf, &configModules)

	if err != nil {
		log.Fatal()
	}
	for i := 0; i < len(configModules.Modules); i++ {
		fmt.Printf("\nmodule: %s\nresources: %v\n", configModules.Modules[i].Name, configModules.Modules[i].Resources)
	}
	return configModules
}

func ReadTfFiles(fileName string) ParsedTf {
	tfFile := fmt.Sprintf("%s/main.tf", strings.TrimSuffix(fileName, "/"))
	tfFiles, err := os.ReadDir(strings.TrimSuffix(fileName, "/"))
	allTf := []byte("")

	for i := len(tfFiles) - 1; i >= 0; i-- {
		v := tfFiles[i]
		if strings.HasSuffix(v.Name(), ".tf") {
			fmt.Println(v.Name())
			currentTfFile, err := os.ReadFile(fileName + v.Name())
			if err != nil {
				log.Fatal(err)
			}
			allTf = append(allTf, currentTfFile...)
		}
	}

	if err != nil {
		log.Fatalf("ERROR: %s doesn't exist", tfFile)
	} else {
		fmt.Printf("Reading terraform main from %s\n", util.EmphasizeStr(tfFile, util.Yellow, util.Normal))
	}

	return ReadTf(allTf)
}

// ReadTf reads the contents of the *tf* files produced by aztfexport and
// returns a struct with the providers and resources in it
func ReadTf(raw []byte) ParsedTf {
	file := string(raw[:])
	fileLines := strings.Split(file, "\n")

	isProv := false
	isResource := false
	isBlock := false
	isDependsOn := false

	var rawProv []string
	var rawResource []string

	var currentBlock string

	for i := 0; i < len(fileLines); i++ {

		if !isBlock {

			firstWord := strings.Split(fileLines[i], " ")[0]

			if firstWord == "resource" {
				// fmt.Print("\nStart of resource\n")
				isResource = true
				isBlock = true
			} else if firstWord == "terraform" || firstWord == "provider" {
				// fmt.Print("\nStart of provider/tf\n")
				isBlock = true
				isProv = true
			} else {
				currentBlock = ""
				isBlock = false
			}
		}
		if fileLines[i] == "}" && isBlock {
			if isResource {
				currentBlock += fileLines[i]
				rawResource = append(rawResource, currentBlock)
				isResource = false
				isBlock = false
				currentBlock = ""
			} else if isProv {
				currentBlock += fileLines[i]
				rawProv = append(rawProv, currentBlock)
				isProv = false
				isBlock = false
				currentBlock = ""
			}
		}
		if isBlock {
			if !isDependsOn {
				// if util.FirstWordIs(fileLines[i])
				firstWordInside := strings.Split(strings.TrimSpace(fileLines[i]), " ")[0]

				if firstWordInside == "depends_on" {
					isDependsOn = true
				} else {
					currentBlock += fileLines[i] + "\n"
				}
			} else {
				firstWordInside := strings.Split(strings.TrimSpace(fileLines[i]), " ")[0]
				if firstWordInside == "]" {
					isDependsOn = false
				}
			}
		}

	}
	return ParsedTf{
		Resources: rawResource,
		Providers: rawProv,
	}
}

type VarsContents []map[string]interface{}

// CreateVars creates a structured map[resource_name]contents{}
// to use in tfvars, variables, modules, etc.
// func CreateVars(rawResources []string, modules []Modules) map[string][]string {
func CreateVars(rawResources []string, modules []Modules) map[string]VarsContents {
	// var vars map[string][]map[string]interface{}
	// var vars map[string][]string = make(map[string][]string)
	var vars map[string]VarsContents = make(map[string]VarsContents)

	for _, v := range modules {
		for _, resource := range rawResources {
			resoureceArray := strings.Split(resource, "\n")
			rawResourceName := strings.Split(resource, "\"")[1]
			resourceName := strings.Replace(rawResourceName, "azurerm_", "", 1) + "s"

			blockContent := strings.Join(resoureceArray[1:len(resoureceArray)-1], "\n")

			if slices.Contains(v.Resources, rawResourceName) {
				// fmt.Println("\nRaw block content:")
				// fmt.Println(blockContent)
				newResource := ParseResource(blockContent)
				// fmt.Printf("\n%v\n", newResource)
				vars[resourceName] = append(vars[resourceName], newResource)
			}
		}
	}
	return vars
}

func stringExists(slice []string, str string) bool {
	for _, v := range slice {
		if v == str {
			return true
		}
	}
	return false
}
func ParseResource(rawResource string) map[string]interface{} {
	var resource map[string]interface{}
	content := ""
	//separa tudo por linhas
	stringArr := strings.Split(rawResource, "\n")
	//percorre linha a linha
	i := 0
	last_var := ""
	v := ""
	for i < len(stringArr) {
		v = stringArr[i]
		//split da linha por espacos
		splittedStr := strings.Split(strings.TrimSpace(v), " ")
		//Dentro de um block
		if slices.Contains(splittedStr, "{") && !slices.Contains(splittedStr, "=") {
			last_var = splittedStr[0]
			content += "\"" + splittedStr[0] + "\" = [\n"
			content += "{\n"
			i, content = insideBracket(stringArr, i, content)
			still_first_string := true
			i += 1
			for still_first_string && i < len(stringArr) {
				v = stringArr[i]
				splittedStr := strings.Split(strings.TrimSpace(v), " ")
				// ainda dentro do bloco
				if last_var == splittedStr[0] {
					content += "\n{\n"
					i, content = insideBracket(stringArr, i, content)
					i++
				} else {
					if content[len(content)-1] == ',' {
						content = content[:len(content)-1]
						content += "\n"
					}
					content += "],\n"
					still_first_string = false
					i--
				}
			}
		} else if slices.Contains(splittedStr, "{") {
			content += "\"" + splittedStr[0] + "\" = {\n"
			i, content = insideBracket(stringArr, i, content)
		} else {
			v = stringArr[i]
			splittedStr := strings.Split(strings.TrimSpace(v), " ")
			content += fmt.Sprintf("\"%s\" %s", splittedStr[0], strings.Join(splittedStr[1:], " "))
			content += ",\n"
		}
		i++
	}

	if countChar(content, '[') != countChar(content, ']') {
		content = content[:len(content)-1]
		content += "\n],\n"
	}
	if content[len(content)-1] == '\n' {
		content = content[:len(content)-1]
	}
	if content[len(content)-1] == ',' {
		content = content[:len(content)-1]
		content += "\n"
	}

	jsonedString := "{" + strings.ReplaceAll(content, "=", ":") + "\n}"
	fmt.Println(jsonedString)
	err := json.Unmarshal([]byte(jsonedString), &resource)
	if err != nil {
		fmt.Println("Here", err)
	}

	return resource
}

func countChar(s string, char rune) int {
	count := 0
	for _, c := range s {
		if c == char {
			count++
		}
	}
	return count
}

func insideBracket(stringArr []string, i int, content string) (int, string) {
	bracket_count := 1
	for bracket_count > 0 {
		i++
		v := stringArr[i]
		splittedStr := strings.Split(strings.TrimSpace(v), " ")
		if slices.Contains(splittedStr, "{") {
			content += "\"" + splittedStr[0] + "\" : {\n"
			bracket_count += 1
		} else if slices.Contains(splittedStr, "}") {
			//falta retirar ultima virgula
			if content[len(content)-1] == ',' {
				content = content[:len(content)-1]
				content += "\n"
			}
			content += "},"
			bracket_count -= 1
		} else {
			content += "\n"
			content += fmt.Sprintf("\"%s\" %s", splittedStr[0], strings.Join(splittedStr[1:], " "))
			content += ","
		}
	}
	return i, content
}

// ParseResource converts the contents of a resource block into a map
func ParseResource2(rawResource string) map[string]interface{} {
	fmt.Println("-------------------")
	fmt.Println(rawResource)
	fmt.Println("-------------------")
	var keys_array []string
	var resource map[string]interface{}
	stringArr := strings.Split(rawResource, "\n")
	quotedString := ""
	includesInnerBlock := 0
	inner_block_first := false

	for i, v := range stringArr {
		splittedStr := strings.Split(strings.TrimSpace(v), " ")
		if slices.Contains(splittedStr, "{") {
			inner_block_first = true
			if !strings.Contains(v, "=") {
				splittedStr = slices.Insert(splittedStr, 1, "=")
			}
			if stringExists(keys_array, splittedStr[0]) {
				inner_block_first = false
			} else {
				quotedString += "\"" + splittedStr[0] + "\" = [\n"
				keys_array = append(keys_array, splittedStr[0])
			}

			includesInnerBlock += 1
		}
		// fmt.Println(includesInnerBlock)
		if splittedStr[0] == "}" {
			quotedString += "}"
			includesInnerBlock -= 1
		} else {
			if len(keys_array) == 0 {
				quotedString += fmt.Sprintf("\"%s\" %s", splittedStr[0], strings.Join(splittedStr[1:], " "))
			}
		}
		if inner_block_first && includesInnerBlock == 0 && len(keys_array) > 0 {
			quotedString += "]\n"
			keys_array = []string{}
		}

		if includesInnerBlock != 0 {
			if !slices.Contains(splittedStr, "{") && strings.TrimSpace(stringArr[i+1]) != "}" {
				quotedString += ",\n"
			} else {
				quotedString += "\n"
			}
		} else if i != len(stringArr)-1 {
			quotedString += ",\n"
		}

		// if includesInnerBlock {
		// 	quotedString += "\n"
		// }
	}

	fmt.Println(quotedString)
	jsonedString := "{" + strings.ReplaceAll(quotedString, "=", ":") + "\n}"
	err := json.Unmarshal([]byte(jsonedString), &resource)
	if err != nil {
		fmt.Println("Here", err)
	}

	return resource
}

type Resource struct {
	ResourceID   string `json:"resource_id"`
	ResourceType string `json:"resource_type"`
	ResourceName string `json:"resource_name"`
}

func JsonParser(fileName string) []Resource {
	fileContent, err := ioutil.ReadFile(fileName)
	if err != nil {
		log.Fatalf("Failed reading the file: %s", err)
	}

	var resources []Resource

	jsonparser.ObjectEach(fileContent, func(key []byte, value []byte, dataType jsonparser.ValueType, offset int) error {
		var res Resource
		jsonparser.ObjectEach(value, func(innerKey []byte, innerValue []byte, innerDataType jsonparser.ValueType, innerOffset int) error {
			switch strings.ToLower(string(innerKey)) {
			case "resource_id":
				res.ResourceID = string(innerValue)
			case "resource_type":
				res.ResourceType = string(innerValue)
			case "resource_name":
				res.ResourceName = string(innerValue)
			}
			return nil
		})
		resources = append(resources, res)
		return nil
	})

	return resources
}

func GenerateImports(resources []Resource, modules F) string {

	resourceModuleMapping := make(map[string]string)
	for _, module := range modules.Modules {
		for _, resourceType := range module.Resources {
			resourceModuleMapping[resourceType] = module.Name
		}
	}

	typeCounter := make(map[string]int)

	var output, otherOutput strings.Builder
	for _, resource := range resources {
		index, exists := typeCounter[resource.ResourceType]
		if !exists {
			typeCounter[resource.ResourceType] = 1
		} else {
			typeCounter[resource.ResourceType] = index + 1
		}

		moduleName, found := resourceModuleMapping[resource.ResourceType]
		resource_type := strings.Replace(resource.ResourceType, "azurerm", "res", 1)
		if found {
			formattedResourceType := fmt.Sprintf("module.%s.%s.%ss[\"%d\"]", moduleName, resource.ResourceType, resource_type, index)
			output.WriteString(fmt.Sprintf("import {\n  to = %s\n  id = \"%s\"\n}\n\n", formattedResourceType, resource.ResourceID))
		} else {
			otherOutput.WriteString(fmt.Sprintf("%s\n", resource.ResourceType))
		}
	}

	finalString := output.String()

	fmt.Println("\nUnmapped Resources:")
	fmt.Println(otherOutput.String())

	// Write to imports.tf
	err := ioutil.WriteFile("./output/imports.tf", []byte(output.String()), 0644)
	if err != nil {
		log.Fatalf("Failed writing to imports.tf: %s", err)
	}

	// Write to unmapped_resources.txt
	err = ioutil.WriteFile("./output/unmapped_resources.txt", []byte(otherOutput.String()), 0644)
	if err != nil {
		log.Fatalf("Failed writing to unmapped_resources.txt: %s", err)
	}

	fmt.Println("Data written to files successfully!")

	return finalString
}

///////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

type ModuleResource struct {
	Module       string
	ResourceType string
}

func ParseCSV(filename string) []ModuleResource {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatalf("Error: csv file does not exist: %s", err)
	}
	defer file.Close()

	r := csv.NewReader(file)

	// Read and discard header
	_, err = r.Read()
	if err != nil {
		log.Fatalf("Error reading the csv file: %s", err)
	}

	rows, err := r.ReadAll()
	if err != nil {
		log.Fatalf("Error reading the csv file: %s", err)
	}

	var resources []ModuleResource
	for _, row := range rows {
		if len(row) < 2 {
			// Skip rows with fewer than 2 fields or handle the error accordingly
			fmt.Printf("Warning: encountered a row with fewer than 2 fields: %v. Skipping.\n", row)
			continue
		}
		resources = append(resources, ModuleResource{
			Module:       row[0],
			ResourceType: row[1],
		})
	}

	return resources
}

func AddResource(resources *[]ModuleResource, item ModuleResource) {
	// Create a map to check for existing items.
	existing := make(map[string]bool)

	// Populate the map based on the current items.
	for _, resource := range *resources {
		key := resource.Module + "|" + resource.ResourceType
		existing[key] = true
	}

	// Check if the item exists.
	key := item.Module + "|" + item.ResourceType
	if !existing[key] {
		*resources = append(*resources, item)
	}
}

func GenerateModuleYaml(resourcesMapping []Resource, modules_map []ModuleResource) []ModuleResource {
	var resources []ModuleResource
	for _, resource := range resourcesMapping {
		for _, mapped_resource := range modules_map {
			if resource.ResourceType == mapped_resource.ResourceType {
				AddResource(&resources, mapped_resource)
			}
		}
	}
	return resources
}

func transform(resources []ModuleResource) []Modules {
	grouped := make(map[string][]string)

	for _, r := range resources {
		grouped[r.Module] = append(grouped[r.Module], r.ResourceType)
	}

	var yamlResources []Modules
	for moduleName, resourceTypes := range grouped {
		yamlResources = append(yamlResources, Modules{
			Name:      moduleName,
			Resources: resourceTypes,
		})
	}

	return yamlResources
}

func WriteYaml(filename string, resources []ModuleResource) {
	yamlResources := transform(resources)

	data, err := yaml.Marshal(map[string][]Modules{"modules": yamlResources})
	if err != nil {
		log.Fatalf("Error writing YAML: %v", err)
	}
	configData, err := yaml.Marshal(map[string][]string{
		"config": {"one", "two"},
	})
	data = append(data, configData...)
	ioutil.WriteFile(filename, data, 0644)
	fmt.Println("YAML written to tfmodule.yaml")
}
