// Package inout contains functions that deal with io
// operations, reading and writing the contents of the
// files generated by [scf]
package inout

import (
	"encoding/csv"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/buger/jsonparser"
	"github.com/sergio-prgm/tf-module/pkg/util"
	"gopkg.in/yaml.v3"
)

type Modules struct {
	Name      string   `yaml:"name"`
	Resources []string `yaml:"resources"`
}

type YamlMapping struct {
	Modules []Modules `yaml:"modules"`
	Confg   []string  `yaml:"config"`
}

type ParsedTf struct {
	Providers []string
	Resources []string
}

type Resource struct {
	ResourceID   string `json:"resource_id"`
	ResourceType string `json:"resource_type"`
	ResourceName string `json:"resource_name"`
}

type ModuleResource struct {
	Module       string
	ResourceType string
}

// ReadConfig creates a structured YamlMapping
// to use in tfvars, variables, modules, etc.
func ReadConfig(fileName string) YamlMapping {
	filePath := fmt.Sprintf("%s/tfmodule.yaml", strings.TrimSuffix(fileName, "/"))
	conf, err := os.ReadFile(filePath)

	if err != nil {
		log.Fatalf("ERROR: %s doesn't exist", filePath)
	} else {
		fmt.Printf("Reading modules from %s\n", util.EmphasizeStr(filePath, util.Yellow, util.Normal))
	}

	return ParseConfig(conf)
}

// ParseConfig
// parses the contents of the provided yaml file into a YamlMapping structure
func ParseConfig(conf []byte) YamlMapping {
	configModules := YamlMapping{}
	err := yaml.Unmarshal(conf, &configModules)

	if err != nil {
		log.Fatal()
	}
	return configModules
}

// ParseConfig
// read the contents of the tf files and parses into a ParsedTf structure
func ReadTfFiles(fileName string) ParsedTf {
	tfFile := fmt.Sprintf("%s/main.tf", strings.TrimSuffix(fileName, "/"))
	tfFiles, err := os.ReadDir(strings.TrimSuffix(fileName, "/"))
	allTf := []byte("")

	for i := len(tfFiles) - 1; i >= 0; i-- {
		v := tfFiles[i]
		if strings.HasSuffix(v.Name(), ".tf") {
			fmt.Println(v.Name())
			currentTfFile, err := os.ReadFile(fileName + v.Name())
			if err != nil {
				log.Fatal(err)
			}
			allTf = append(allTf, currentTfFile...)
		}
	}

	if err != nil {
		log.Fatalf("ERROR: %s doesn't exist", tfFile)
	} else {
		fmt.Printf("Reading terraform main from %s\n", util.EmphasizeStr(tfFile, util.Yellow, util.Normal))
	}

	return ReadTf(allTf)
}

// ReadTf
// parses the contents provided of the raw []byte and returns a structure of ParsedTf with the providers and resources
func ReadTf(raw []byte) ParsedTf {
	file := string(raw[:])
	fileLines := strings.Split(file, "\n")

	isProv := false
	isResource := false
	isBlock := false
	isDependsOn := false

	var rawProv []string
	var rawResource []string

	var currentBlock string

	for i := 0; i < len(fileLines); i++ {

		if !isBlock {

			firstWord := strings.Split(fileLines[i], " ")[0]

			if firstWord == "resource" {
				// fmt.Print("\nStart of resource\n")
				isResource = true
				isBlock = true
			} else if firstWord == "terraform" || firstWord == "provider" {
				// fmt.Print("\nStart of provider/tf\n")
				isBlock = true
				isProv = true
			} else {
				currentBlock = ""
				isBlock = false
			}
		}
		if fileLines[i] == "}" && isBlock {
			if isResource {
				currentBlock += fileLines[i]
				rawResource = append(rawResource, currentBlock)
				isResource = false
				isBlock = false
				currentBlock = ""
			} else if isProv {
				currentBlock += fileLines[i]
				rawProv = append(rawProv, currentBlock)
				isProv = false
				isBlock = false
				currentBlock = ""
			}
		}
		if isBlock {
			if !isDependsOn {
				// if util.FirstWordIs(fileLines[i])
				firstWordInside := strings.Split(strings.TrimSpace(fileLines[i]), " ")[0]

				if firstWordInside == "depends_on" {
					isDependsOn = true
				} else {
					currentBlock += fileLines[i] + "\n"
				}
			} else {
				firstWordInside := strings.Split(strings.TrimSpace(fileLines[i]), " ")[0]
				if firstWordInside == "]" {
					isDependsOn = false
				}
			}
		}

	}
	return ParsedTf{
		Resources: rawResource,
		Providers: rawProv,
	}
}

// JsonParser
// read the json file provided and parse each resource into an array of structured Resource
func JsonParser(fileName string) []Resource {
	fileContent, err := ioutil.ReadFile(fileName)
	if err != nil {
		log.Fatalf("Failed reading the file: %s", err)
	}

	var resources []Resource

	jsonparser.ObjectEach(fileContent, func(key []byte, value []byte, dataType jsonparser.ValueType, offset int) error {
		var res Resource
		jsonparser.ObjectEach(value, func(innerKey []byte, innerValue []byte, innerDataType jsonparser.ValueType, innerOffset int) error {
			switch strings.ToLower(string(innerKey)) {
			case "resource_id":
				res.ResourceID = string(innerValue)
			case "resource_type":
				res.ResourceType = string(innerValue)
			case "resource_name":
				res.ResourceName = string(innerValue)
			}
			return nil
		})
		resources = append(resources, res)
		return nil
	})

	return resources
}

// ParseCSV
// read the csv file provided and parse each resource with is module into an array of structured ModuleResource
func ParseCSV(filename string) []ModuleResource {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatalf("Error: csv file does not exist: %s", err)
	}
	defer file.Close()

	r := csv.NewReader(file)

	// Read and discard header
	_, err = r.Read()
	if err != nil {
		log.Fatalf("Error reading the csv file: %s", err)
	}

	rows, err := r.ReadAll()
	if err != nil {
		log.Fatalf("Error reading the csv file: %s", err)
	}

	var resources []ModuleResource
	for _, row := range rows {
		if len(row) < 2 {
			// Skip rows with fewer than 2 fields or handle the error accordingly
			fmt.Printf("Warning: encountered a row with fewer than 2 fields: %v. Skipping.\n", row)
			continue
		}
		resources = append(resources, ModuleResource{
			Module:       row[0],
			ResourceType: row[1],
		})
	}

	return resources
}

// transform
// It takes an array of structured ModuleResource and transform it into an array of structured Modules to write the yaml file
func transform(resources []ModuleResource) []Modules {
	grouped := make(map[string][]string)

	for _, r := range resources {
		grouped[r.Module] = append(grouped[r.Module], r.ResourceType)
	}

	var yamlResources []Modules
	for moduleName, resourceTypes := range grouped {
		yamlResources = append(yamlResources, Modules{
			Name:      moduleName,
			Resources: resourceTypes,
		})
	}

	return yamlResources
}

// WriteYaml
// It takes an filename and the resources and transform them to module syntax to write the Yaml file
func WriteYaml(filename string, resources []ModuleResource) {
	yamlResources := transform(resources)

	data, err := yaml.Marshal(map[string][]Modules{"modules": yamlResources})
	if err != nil {
		log.Fatalf("Error writing YAML: %v", err)
	}
	configData, err := yaml.Marshal(map[string][]string{
		"config": {"one", "two"},
	})
	data = append(data, configData...)
	ioutil.WriteFile(filename, data, 0644)
	fmt.Println("YAML written to tfmodule.yaml")
}

// WriteToFile
// It takes the content, the filename path and a success string and writes the content to the file and prints the success string
func WriteToFile(content string, path string, success string) {
	err := ioutil.WriteFile(path, []byte(content), 0644)
	if err != nil {
		log.Fatalf("Failed writing to %s: %s", path, err)
	} else {
		fmt.Println(success)
	}
}
